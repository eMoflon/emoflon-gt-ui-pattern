/*
 * generated by Xtext 2.11.0
 */
package org.moflon.gt.mosl.pattern.language.validation

import org.eclipse.xtext.validation.Check
import org.moflon.gt.mosl.pattern.language.moslPattern.Constraint
import org.moflon.gt.mosl.pattern.language.moslPattern.EnumExpression
import org.moflon.gt.mosl.pattern.language.moslPattern.LiteralExpression
import org.eclipse.emf.ecore.EDataType
import org.moflon.gt.mosl.pattern.language.moslPattern.AttributeExpression
import org.moflon.gt.mosl.pattern.language.moslPattern.ConstraintArgument
import org.moflon.gt.mosl.pattern.language.moslPattern.MoslPatternPackage
import org.moflon.gt.mosl.pattern.language.moslPattern.ConstraintDef
import org.moflon.gt.mosl.pattern.language.exceptions.LibFolderDoesnNotExistException
import org.moflon.gt.mosl.pattern.language.exceptions.LibFileDoesnotExitException

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class MOSLPatternValidator extends AbstractMOSLPatternValidation {

	public static val TOO_MANY_ARGUMENTS_CONSTRAINTS = 'tooManyArgumentsConstraints'
	public static val TOO_FEW_ARGUMENTS_CONSTRAINTS = 'tooFewArgumentsConstraints'
	public static val CANNOT_RESOLVE_TYPE_CONSTRAINTS = 'cannotResolveTypeConstraints'
	public static val LIBRARY_FOLDER_DOES_NOT_EXIST = 'libraryFolderDoesNotExist'
	public static val LIBRARY_FILE_DOES_NOT_EXIST = 'libraryFileDoesNotExist'
	public static val CONSTRAINT_SPECIFICATION_DOES_NOT_EXIST = 'constraintSpecificationDoesNotExist'

	@Check
	def checkCorrectTypeFromArgumentToParameter(Constraint constraint) {
		val definitionTypes = constraint.name.parameters.map[param|param.type].toList
		val usedTypes = constraint.args.map[arg|findTypeFromConstraintArgument(arg)].toList
		if (definitionTypes.size < usedTypes.size) {
			error("Too many arguments for" + constraint.name.name, constraint,
				MoslPatternPackage.Literals.CONSTRAINT__ARGS, TOO_MANY_ARGUMENTS_CONSTRAINTS)
		} else if (definitionTypes.size > usedTypes.size) {
			error("Too few arguments for" + constraint.name.name, constraint,
				MoslPatternPackage.Literals.CONSTRAINT__ARGS, TOO_FEW_ARGUMENTS_CONSTRAINTS)
		}

		for (var index = 0; index < usedTypes.size; index++) {
			val defType = definitionTypes.get(index)
			val usedType = usedTypes.get(index)
			if (usedType !== defType) {
				error(usedType.name + " cannot be resolved to a variable of " + defType.name, constraint,
					MoslPatternPackage.Literals.CONSTRAINT__ARGS, CANNOT_RESOLVE_TYPE_CONSTRAINTS)
			}
		}
	}

	def EDataType findTypeFromConstraintArgument(ConstraintArgument constArg) {
		if (constArg instanceof AttributeExpression) {
			val type = constArg.getName().getEType();
			if (type instanceof EDataType)
				return type;
		} else if (constArg instanceof LiteralExpression) {
			return MOSLPatternValidatorUtil.instance.getLiteralExpressionType(constArg);
		} else if (constArg instanceof EnumExpression) {
			return constArg.eenum
		}

		throw new RuntimeException("Wrong Type");
	}
	@Check
	def checkConstraintDefIsConnected(ConstraintDef constrainDef){
		try{
			val found=MOSLPatternValidatorUtil.instance.isConnected(constrainDef);
			if(!found)
			error("ConstrainSpecification: " + constrainDef.name + " does not exist!", constrainDef, MoslPatternPackage.Literals.DEFINITION__NAME, CONSTRAINT_SPECIFICATION_DOES_NOT_EXIST)
		}catch (LibFolderDoesnNotExistException lFolderE){
			error("Library folder not found!", constrainDef, MoslPatternPackage.Literals.DEFINITION__NAME, LIBRARY_FOLDER_DOES_NOT_EXIST)
		}catch (LibFileDoesnotExitException lFileE){
			error("Library file not found!", constrainDef, MoslPatternPackage.Literals.DEFINITION__NAME, LIBRARY_FILE_DOES_NOT_EXIST)
		}

	}
}
